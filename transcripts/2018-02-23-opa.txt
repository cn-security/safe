Dan:                Hey. Can folks hear me?

Tauren:             Yep.

Dan:                Great. Great. I've been back and forth between in Hangouts in Zoom all morning and sometimes the audio gets lost. So, if you haven't checked in the docs, please add yourself to the docs. Looking for two individuals ... really did not do a good job at sort of capturing the notes last session. And I apologize for that. So, looking for two volunteers to focus on minutes. Capturing some minutes, especially as we're getting these use cases. I want to make sure the questions and answers. Since, those will be sort of key things that will help us build our case.
                    Turner, are you presenting? Who's presenting on your side?

Speaker 3:          You don't have audio.

Dan:                Turner. Tim. Who's presenting today?

Tim:                Yeah. I've got the slides. 

Dan:                Cool. You want to test your slides out while we're waiting for folks to log on?

Tim:                Sure.

Tauren:             Yeah. Hey, Dan. I think a couple of us are having an issue accessing the doc.

Dan:                All right. Let me ...

Tauren:             We can give [inaudible 00:03:13].

Dan:                Give everybody the request for access. It's Google Docs. Think I've got ... Should have open editing while we're live.

Tim:                Oh. I don't even have permission to view it. 

Tauren:             Yeah. Me neither.

Dan:                Okay. No, no. There is an issue. It was closed to the group. Anybody in the domain had it ... On the web. And then, click. There we go. All right. Sorry about that. [inaudible 00:03:49]. Should have access now. So for everyone's that's logging on, I've got in the chat the meeting notes, please add yourself.

Tauren:             I can volunteer to take some of this.

Dan:                Great, great. Thank you, appreciate that. Could I get someone else to help support Turner? One more volunteer then we'll get started.

Speaker 3:          [crosstalk 00:05:09]. I can help take notes but I don't have ... Okay. That's [inaudible 00:05:15].

Dan:                You should have access now. I'm going through and adding everybody in this sort of cumbersome Google Docs process of adding people. All right. Continuing today with our use cases, we have the OPA use case that we're going to dive into. Thanks again to Sheree for sharing the Bob Founder use case. That was a great discussion and really insightful to get that context. We had a number of folks who had the opportunity to collaborate with OPA so we wanted to take the full session today to go through the use cases and hear a bit about the journey that the team behind OPA's been going through and go through some questions and answers today.
                    I forget who's got ... Tim, is that you that has the slides up? Sorry.

Tim:                Yep.

Dan:                All right. So Tim, go ahead, take it away.

Tim:                Okay, thanks. What I thought I'd do is spend a few minutes just giving you a quick overview of OPA and sort of setting the stage there and then talking just a little bit about the process, the journey, as you say, that we've gone through and then diving into the use cases. Obviously that's meat of the discussion but I thought we should set the stage at first.
                    And so, the first thing that I think to mention is just sort of the goal of OPA. The goal OPA has always been to make it easy to add rich policy support to other projects and services. Right? That's been the goal. And I think of OPA sort of like a library in that sense, but the idea is really that you've got like, as this picture shows, what we expect to have happened is that OPA's is running in a bunch of different places and you know those OPA's are integrated with different kinds of systems, like maybe in the micro service case, you've integrated OPA with all the different micro services that are running.
                    Or maybe you're integrating OPA into different components of kubernetes or into Linux or into all kinds of different places and we'll go into what some of those use cases are and what people have found OPA useful for. But then the idea is that we want to make OPA really easy to use and take sorta zero runtime dependencies. That's always been one of the goals, to make it very easy to integrate, very easy to deploy. And then the idea behind OPA is that it's really intended to be something that can make policy decisions for something running right next to it. Right? So we like to think of this as a host local kind of daemon that knows how to make authorization, or more generally policy decisions for anything that's running on that host.
                    But the goal of OPA has never been to be a service. It's always just designed to be basically a library or something that answers questions from services they're sitting on the host. And so, the sort of the sort of management of how you integrate and deal with multiple OPA's has always been and out of scope for OPA. And so, I think you know from my understanding of what Safe is designing to do, this seems like a natural fit for Safe.
                    All right. So I think that was the goal. I'll skip through some of this. Everybody here knows roughly what the policy problem is, I'm assuming, and so one of the things that OPA does provide as a declarative language, those designed to work fundamentally with JSON data. We'll see some examples and use cases there. I already went through this, it's a library daemon. It's all written in Go, so if you want to integrate as a library you've got to have your service written in Go.
                    All storage of data and policy, all of that is done in memory. Right? And so, having a management piece that is capable of actually feeding OPA those policies and any data it needs is valuable there. Now we've done a bunch of work around tooling as well. So it OPA has an environment where can go into and run and ask for the results of evaluating ad-hoc queries or just running the policy even without having deployed it. There's a test framework for writing unit tests. There's tracing to do debug ability and we're working on some profiling stuff to look at performance. 
                    We are working on a standard library as well so that you don't have to write policies from scratch, you go and you pull them in and immediately you're up and running without even necessarily having to write policy. And then what we're going to do is ,for the most part, focus on a bunch of these integrations today. Any questions so far?

Dan:                Sounds good.

Tim:                All right. I'll keep hammering away. Okay, so conceptually the way that OPA works is that, remember the goal of OPA is to add policy support to an existing project or service. And so here we have sort of a pictorial representation of that. So we have some service, it doesn't matter what it is, maybe it's a micro service, maybe it's kubernetes, maybe it's Kafka. And then what you do is you ... there's an API that OPA exposes so that that service can ask for policy decisions for enforcement decisions. So the idea is that the service, anytime it needs an authorization decision it opens up a simple HTTP request and asks OPA for that decision.
                    Independently there's a management API that's used for OPA and through that API you actually provide OPA with two different conceptual pieces of information. One is logic, this is sort of like the policy that you would expect. Right? Allow this user to run this API call under these conditions, that's kind of the logic. We use Rego, that's the language for expressing that logic. And then in addition though you can provide OPA with arbitrary JSON data. And so typically what this data represents is something that's happening in the world. So in the kubernetes case this might be all the  pods that exist or in the micro servers case may be the data is you know something like your org chart so that you know who's the manager of whom.
                    All right. And so these are the two kinds of API's that OPA exposes. In particular they're both sort of initiated by things outside of OPA. So today the service is the thing that initiates the request, it says OPA, tell me what a decision is. And likewise, on the management side, there's some external management system that needs to actually push that logic and that data into OPA.
                    And so what we end up doing, at least for some of the integrations, for some of the use cases that we've done, is that we've added a service specific management side card to OPA. So for example, with kubernetes what we've done is there's a side card that runs next to OPA that goes and pulls policies out of the kubernetes API server and pushes them into OPA and likewise, that coop sidecar will go off and grab, let's say, all of the pods that are currently running the API server and push that as data into OPA.
                    And so, that's sort of the division that we saw earlier which is that OPA is really intended to be this be hosts local policy engine that makes decisions. That's a completely separate from it from the management piece. All right, questions about that?

Dan:                Yes, I have a question. You mentioned that you pull the policies out of the creditors API server, are those the [inaudible 00:12:47] policies? So do you essentially have an enforcement for [inaudible 00:12:51] policies in OPA?

Tim:                Not today, not today. We could. In fact [Tauren 00:12:59] did translation of ... he had a collection of our Bach policies and showed how you could write him an OPA. We didn't automate that, it's all as Tauren said. But yeah, we've definitely talked about adding that kind of functionality where you could take an existing policy language and then compile it down into OPA's. But what we did do or what exists is called the coop management ... through coop management repo within the open policy agent GitHub org. What that actually does is it pulls OPA policies out of a conflict map inside of kubernetes and then pushes them into OPA.
                    So the way that you sort of use OPA, for at least a couple of the kubernetes use cases, is that you write your policy and you push it in as conflict maps.

Dan:                Okay, okay. All right, thanks.

Tim:                Yep. Anything else? Okay. I mentioned the API is in the last slide and so I figured, especially given some of the interests of this group, it was worth spending a couple minutes just talking about what API's OPA supports today, to give you a better feel for this. So really there are two kinds of API's that OPA supports.
                    Here the top four are really the management API that I spoke about. And then there's really one, at least there's one main one for doing enforcement. Right? So, on the ... Well I guess I should start with the management. In the management API, there's really just crud on policies, that's the first two lines, and then there's crud on data. Right?
                    So remember for us, we've got these two things that come in, the policies and the data. And so really there's just sort of standard management API's for dealing with both the management and data, getting them in and out and updating them within OPA. So those are the first four API's. And then the fifth API is really the one that asks for a policy decision. Right? Here the idea is just basically open up a GET request, and so all that the service needs to do is run a GET request on basically a URL that names the policy that they want the decision from. Okay? And so it's really pretty much that simple in terms of the API.
                    The one thing I'll mention here that's noteworthy in this sort of REST API space is that all of the policies and all of the data are registered at human readable path names. When you create a policy you can create it at foo slash bar slash baz in the API and then that's reflected in the policy language as well. The same is true of data, you can register data or whatever path you like and then decisions are also named via path. So you could ask for a decision which is like decisions slash microservice slash app a and then you get the decisions that are for the policy that's registered at that point.
                    Any questions?

Tauren:             The only other thing I would throw in is just those policy decisions, when you get them, you can provide arbitrary JSON input when you ask those decisions. You can represent the API requests you want to authorize or whatever it is, JSON, you just pass that into the body of the post requested.

Tim:                Yeah. And it turns out that, I can't remember if I mentioned the term domain agnostic here in the intro to OPA but the idea behind OPA is that it should work for any kind of domain that we like, and in order to make that happen sort of what ends up working is that when you pass ... when a service makes a request for a decision from OPA, the input that it provides can be any arbitrary JSON document and that's how OPA achieves this domain agnosticity, if that's a word. The idea being that because you can pass in any arbitrary input, that input could represent the microservice API call, such as the method, path and user or it could represent a request to do an SSH, which is here's the host ID and the user or it could represent a Terraform plan. And we'll see examples of all these things shortly. 

Dan:                Does OPA support approaches for validating data? So for example, if I'm passing a JOT, can you do validation on that?

Tim:                Yeah, so [crosstalk 00:17:21]. Yeah, typically the way that we think about it is that we do trust the input that comes in, we assume that there's some sort of trusted tunnel between the service and OPA but specifically with respect to JOT's I'll mention that we have been asked a couple of times to add enough functionality inside of OPA to actually do that kind of validation in the policy itself. And then the policy language itself today already has enough control to be able to inspect the internals of the job token to make policy decisions using the information contained within that OPA.

Speaker 3:          How are the OPA API's set up for the policy decision secured? How do you authenticate the service itself which is calling into the OPA decision API?

Tim:                So today we have bearer tokens, if you want to do that. Typically what we ... or at least often what we do is we just sort of assume that there's a trusted tunnel there. But yeah, bearer tokens is what exists.

Tauren:             [inaudible 00:18:19] running locally on a host next to the service that a policy [inaudible 00:18:24] so we assume that the host is secure. You can run OPA, the OPA server with TLS enabled, if you need encrypt the traffic, like Tim said, you can configure OPA with bearer tokens for authentication and then obviously OPA would not be complete if you couldn't write authorization policy over the OPA API's themselves. So you can do that as well. So you have support from TLS authentication and authorization on OPA itself. And then some people have been asking about support for mutual TLS authentication, when talking OPA's, that's sort of on the roadmap.

Speaker 3:          Thank you.

Tim:                Okay. So yeah, it felt like for this kind of topic it was worth spending one minute talking about the journey that we've taken to get here and where we are and so we started OPA roughly two years ago, I'll say 2016, and we spent basically the first year building the basic OPA, the language, the API, so on and so forth. Last year we spent basically the whole year investigating how to use OPA to solve other people's real-world problems. Right? And building the community around OPA and getting it out and then taking what we had learned by running through numerous use cases to sort of help find the language and the implementation in the API.
                    And now this year, really, our focus is on like hardening, so we're looking at building the V2 of the language. Some of the folks that I know or I saw on one of the docs, Sarah and Tristan, out of Google, so they're very interested in working with us on V2 of the language. And then we're also looking at ... so trying to do improve the ease of use of the language, make it a little bit more programmer friendly, looking at performance and then of course continuing to solve real-world problems. Right? And building community. What we thought we would do for the rest of the talk is just go through some of the use cases that we've used OPA to solve from a number of different places.
                    All right. All right, so here's our picture of the classes of different use cases that we've solved with OPA. And so we're going go through, I think, most of these, I'll just highlight them. So really remember OPA's designed to be domain agnostic which means you can apply it at really any level of your proverbial stack. Right? So we've applied OPA sort of at the orchestration layer here with kubernetes, at the individual sort of host layer to do like docker and Linux control.
                    We've done integrations with OPA at the sort of public Cloud layer with Terraform to do some risk management. We've solved use cases with OPA at the micro service API layer as well. That's been pretty public around ... we've been probably most public around that with Netflix and STO. Recently we've started getting into or not us necessarily but users have started using OPA to do some data protection stuff in this sort of CAFTA open STS and Mineo space.
                    All right. I'm just going to go through some of these and the ones and ... What I tried to do is sort of just ... we can't go through all 20 or however many integrations but go through sort of the key categories of integrations that we've done in use cases that we've seen. The interesting thing, I did spend some time for this meeting trying to think through some of the different dimensions that we think about when we're looking at a new use case. And so we thought that this would be valuable for this group just because it does sort of highlight some of the different things that you need to think about when you're thinking about a use case, at least in our experience that's the case.
                    I'll just run through these one in time and then, very quickly, but then what I'd like to understand is from this group's position, which of these things are most interesting to you and then I can sorta highlight those as we talk through different use cases. The first one is just sort of basic policy, what kind of policy we're even writing and obviously this is really interesting from an OPA point of view because OPA is fundamentally a language. And so understanding what kinds of policy and what kinds of expressiveness requirements are needed is an important property of any use case.
                    The second thing is data and context and this is typically, from OPA's point of view, data represents kind of what's going on in the world and so sometimes in order to make policy decisions you need information that the requester does not provide. For example, in the micro servers API case, if you want to authorize an API server ... sorry, an API request, you may need to know whether the user that's making that request is a manager in the organization. Right? And that management information is not always something that comes in as part of the request. So what data and context you need to actually make decisions is valuable.
                    The third thing here is what do the decisions look like? Classically with authorization policies the decision is always true/false, it's allow and deny, maybe there are a couple of others like not applicable but fundamentally they're you know often allow/deny and one of the things that we built into OPA from the very early days was the ability to make decisions that were not just allow and deny states, you can return decisions that are numbers. For example, you want to do rate limiting or strings or sets or even dictionaries and there are use cases throughout that will show each of those.
                    The next thing is integration. In some sense you're always at the mercy of the system you're trying to integrate with when it comes to actually doing the integration. So how does that even work? And that's something that we look at for each and every use case and it's always a little bit different. Policy management's the obvious thing that we mentioned earlier which is that every use case, at least for OPA, requires potentially a different kind of management system. And then there's performance. It turns out that use cases can vary widely in terms of performance. We've got some use cases where spending 10 seconds to make a policy decision is fine, others where you have to come in under a millisecond if you're going to make a decision.
                    And then finally is a, terribly named here unfortunately, mode, but here the idea is that they're different ways of actually enforcing policy. One is the sort of obvious one which is that you, we call it proactive here, which is that you stop policy violations before they happen. Right? For example, you don't allow a pod to be deployed in kubernetes unless the policy says it's okay to deploy it. But there's this other version, which is what we're calling reactive, which is that you look at the state of the world and you say here are violations of policy, now I'm going to go off and fix them. Right? And now this is actually more common than you would think, imagine in kubernetes, you actually change your policy and now you've got a bunch of pods that violated that policy, do you want to go off and fix them or do you not? Right? The third kind of thing here is audit, so here the idea is well let's go off and actually just identify violations and then use them and then plug into some external system to actually let people know that they're actually violations in place.
                    Are there questions or comments here? Right, and let me know what things are most important to you. No opinions?

Dan:                When you're in that, your decommissioning state of pods, how easy is it to leave those things behind? That's been a pain point. I haven't experienced that in kubernetes but you know in sort of other orchestration systems having decommissions nodes in there that have the wrong policy has been one of those things where you're pulling your hair out, you're pulling your hair and it's, oh my God, we thought those nodes were gone and they're still there doing the wrong things.

Tim:                Yeah. One of our goals with OPA has always been this idea that you ought to be able to write a single policy and then apply it in any of these different modes or at least to the extent that you can make that happen. And so, at least with coop the nice thing is that once you get to pull all the data about the current state of the world, so whether it's pods or nodes or whatever, into OPA, as we've already articulated then the language itself was sort of designed around the notion of a query language. And so you can just ask the question, well like, tell me which pods and nodes exist that shouldn't, right? Then you can even set up watches that stream the results of that query back out to you. [inaudible 00:27:17] dashboards. I guess I don't know how to answer your question except to answer it with the way OPA would ... the way we would use OPA to help with that kind of problem.

Dan:                Cool.

Tim:                Okay, well I guess as we go ... Sorry, go ahead. 

Sarah:              This is Sarah from Google and one of the things that I think is exciting about OPA from my perspective is the ability to compose policy that might be from disparate services that need to work together, we need to reason about them together, but part of the safe working group is to zoom out a bit and say well we have a whole system that might be using OPA in one place and something else in another and how do we reason about the overall system architecture and policies who are at large? And so, I'm curious about what your thoughts of if we're in a situation where everybody in the world isn't going to use OPA, what are the things that we as a working group might need to define that would help OPA live within an ecosystem that is heterogeneous?

Tim:                Yeah. Obviously, standards things would help here, right? Like having a fairly simple and standard way to ask for decisions, I guess, would help. I'll answer this from the users point which is as a user I'd like to have a consistent way of managing and dealing with all these different kinds of policy systems. What I'd really like though is to be able to reason about how the different policies, presumably in different languages, would interact with each other and it's not clear to me what you can do there from an outside. If we treat all policy languages as black boxes it's not clear to me what you can do there other than to maybe surface actual policy decisions in some sort of format that you know some tooling could come along later and sort of combine them.

Sarah:              Well, I think one of the things like survival hypothesis that generally we're all kind of dealing with the same nouns and verbs for the most part. Let's say nouns, right, there might be some certain amount of where we say okay, if you're deploying an app, right, or micro-service and you're in this world of deploying software that interoperates with other software via GCIP, this set of concerns that you have and if we were to standardize words for those concerns or API's to query or something, then you could imagine people being able to compare equivalent policies. Right? 
                    Obviously if some policy system has capabilities that another policy system doesn't, that's one thing, but what I hear from people who have these heterogeneous infrastructure environments is they want to do something as simple as like, I want to know that these anta points aren't open to the world and I can't even ... I have to write different code for each system to even ask very simple questions and I don't know whether that's ... what form that takes but I think that we have this dream of like you say, having tools that would be able to say, okay I can go across all of these systems and without writing something that is custom for every system that I work with, I know that if it conforms to the safe guidelines, right? That then this tool will be interoperable in some way.

Tim:                Yeah. What I've wondered ... we've talked about this in the past which is that it would be nice, it would be wonderful, if there were some ontology, some schema that everyone in the world agreed on and that represented ... Let's see. Let me go back. Represented all the nouns in this landscape that we see here and I think what ... I've been hesitant to try to go down that road just because it seems ... it feels to me like a like such a gigantic undertaking and that will never be finished. 
                    And so what I think I wonder about is how do we scope what you're talking about to something where it's like it's doable and yet valuable at the same time. I think maybe the right thing to do is to do that from use case perspective and tackle one new use case at a time and once we're happy with that then go on to the next. It's not clear to me what else can be done there when it comes to standardizing the nouns across systems as widely disparate as the ones that are ... that we use it every day.

Sarah:              Yeah. I think there's models for that out there in the world. How did we get to really standard mime types for email? Right? There's processes that where we've done this on the internet before where we start with a few and there's ways to promote something to be what everybody uses and that could be an exercise for the working group.

Dan:                It's painful consensus but that's what we're here for.

Sarah:              What we're hearing is that even a few common things would be high value to the people using these systems. Right? Because a lot of the auditing requires either some kind of manual inspection or custom code too and then that's always worrisome and fragile.

Dan:                Yes. The IBM team, we're sharing how in OpenStack this was just left to vendors and the incompatibility was incredibly cumbersome so it's an opportunity.

Tim:                All right. Maybe I should hammer on and actually talk about some use cases. What we think?

Dan:                Okay.

Tim:                Okay. All right. The first one we're gonna talk about here is Kubb and I'll just kinda rattle on through some of this stuff and then stop me with questions. I'll try to remember but if I don't just jump in. Okay. Kubernetes, we've done actually a number ... we've seen actually a number of different use cases actually within kubernetes itself because there are a number of different places that are extensible enough to support a policy system. And so, at one point we had an integration with the Federation control plane so here the problem, the policy problem, is really giving it a new workload, tell OPA decides which what kubernetes clusters to place that workload on. Right? So that's the use case.
                    There are others at the API server level around authorization and admission control. Here the idea is somebody's trying to create a new pod and now opening to decide either whether to allow it in or not or we've used OPA to actually define the mutations that need to happen to that pod before it's let through. And then in the scheduler we did an integration there as well to actually use policy to control, effectively, which ... to filter out which nodes are not used during scheduling.
                    Okay. So we've got more details on these. The one that we have more details on right here in the slide deck is Admission Control. Here the idea is you've got this pod, effectively, that we're trying to create there on the right-hand side and then the way that works is that there's a web hook that runs inside the API server and the nice thing is here that it's a generic web hook. And so, we didn't actually have to go in and convince kubernetes to talk to OPA, we could just set up OPA as the one hook. 
                    I guess the examples here that we're showing are that some of the policies that people like are, we'll make sure that labels exist, like every pod has a contact email address, control the number of replicas based on the type of application, the type of pod that we're deploying, make sure that there's certain metadata in place from the template. The other one that we've heard several times is let's make sure that all the images in this pod come from a trusted repository, if this is a production cluster.
                    So those are just some of the use cases that we've seen there. Oh, here, I think maybe I'll skip through this, I don't think people here are going to care too much about the language. I will mention though that the ... Let me see. Yeah, here, that the input that comes into OPA when it makes a decision is this gigantic [yamo 00:36:39] thing shown here on the left, right, it is the full pod definition and for the people who know kubernetes RBACH, this is what, in some sense, what differentiates OPA from RBACH, is that when you make policy decisions you get to make them given the entire pod that somebody's trying to create.
                    All right. And then as I mentioned here, the decision in this case could just be true or false, it's allowed or it's not, but it could also be sort of a JSON dictionary that finds what amounts to a JSON patch for updates that must be applied to this pod before it's admitted. Questions there? Okay. Following on this interest in use cases, here are a few other example policies that we've heard people use in the kubernetes admission control space. I'll just let you all sort of scan through those quickly. I won't bother reading them.

Tauren:             We can post the slides online after the meeting and then through them into the notes [inaudible 00:37:49].

Dan:                That'd be great. Yeah. I'll follow up and send that out to everybody.

Tim:                Yeah. All right. Okay. I just check the time, we've got about 20 minutes left. I will skip reading through these things. I'll just pick out a couple highlights. In terms of management, we've already discussed how OPA handles management within kubernetes, right? We had the sidecar that pulls policies out of conflict maps and pushes kubernetes data into OPA. We actually have looked at this for both the proactive/reactive as well as audit perspectives.
                    I think we covered the rest of this here. All right, so let's go on. All right. Another use case and this we've seen quite a bit of interest in, this is sort of micro service API authorization. The idea here, the problem that we're solving is that you've got a whole collection of micro services that are doing what they do and now we need to add authorization on top of it. The idea being here that each and every API call that a micro service sees is something that it sends to OPA to ask for an authorization decision on. Right?
                    And so, conceptually the way that you should think about this is that OPA is running on the same host as every micro-service and so the nice thing then is that you get high performance and high availability, right, you're not in a network hop to go hit some external service to get an authorization decision. And now the idea is that you're using OPA to make those decisions on every API call. 
                    There are different ways of integrating OPA with those micro services. From top to bottom, some folks will actually just do a direct integration with OPA or what we just released, I think this week, was a spring integration where even the developer doesn't even know that OPA's being used but the Java framework is actually taking every API call and authorizing it with OPA. Some folks will actually embed OPA as a library into the micro service. That's the second one. The third one from the top is effectively the service mesh version where you run next to your micro service a sidecar which is a network proxy that handles all the network traffic and then what we do is an integration with that proxy so that that proxy actually asks OPA for authorization decisions on every API call.
                    There's another version in the STO world where OPA was integrated into Mixer, and so it can do centralized decisions there as well. And then the last one here, I think we're just illustrating the fact that if you've got multiple micro services running on a single host, they can all use the same OPA. Here the interesting bit for this use case is here are the inputs that come in, as I mentioned earlier, you can provide a path and a method and the source and a target and a user and then the policy that you write makes a decision about whether or not that API call is authorized. Questions here?
                    Okay. Looking at the dimensions of comparison that we talked about earlier, the performance on this one is critical. Right? If you're the Netflix, the number that Netflix came out with was, actually twice this, so 2,000 requests per second was what you need, at least for them. And so, obviously the ... and I guess I didn't mention this previously but in kubernetes the number was more like a second, right, or a tenth of a second, something like that. And so, obviously the performance demands in this use case are significantly different but ... And so, consequently we ended up adding some functionality to OPA to handle these really mission-critical, performance critical applications and so that was just something that we needed to do.
                    The other thing that we see is that for these kinds of use cases where performance is critical, it also turns out that the amount of data that they typically use is smaller and the policies are written are typically much simpler as well. These decisions are basically allowing denied and false to classic authorization decisions and we've seen people either do these integrations with Go library, running it as the daemon or are the other integrations that we talked about with the service meshes.
                    So this [crosstalk 00:42:09] ... Yeah, go ahead.

Dan:                I see that you have the translation [inaudible 00:42:16] so what's the reason for that, what is the other language?

Tim:                Oh yeah, yeah, right. So this was interesting. So this has come up several times over the last couple months where people want to use OPA for this particular use case but what they want to do is sorta split off. Think of this as maybe a service graph, so they've got some the YAML file that represents a service graph and what they want to do is basically treat that as the actual policy and so then what happens is that you end up writing a little bit of Rego, Rego's the internal OPA language, so you end up writing a little bit of Rego to actually define the semantics that YAML data and then when OPA's is making the decision it will sort of combine that YAML data which defines, let's say, the service graph, along with the Rego that defines its semantics in order to make a decision.
                    Translated into Rego just means that one of the features that we added recently to OPA will take the data and the YAML and the Rego and compile them down into pure Rego, written in a simple form that we can evaluate very quickly. That's the idea there. In the use case it seems like people want to have sort of a secondary front end to providing policy which amounts to YAML or sort of a GUI and then what they want to do is make that very easy for users or application developers to write and then at the same time they want to use OPA to actually do the enforcement.
                    Yeah, we can we'll also maybe post a link to the ...

Tauren:             Yes, I got it up. I've added a link to the bottom [inaudible 00:44:00] and I think that ... Yes. So the idea here is the developers want to provide like RBACH configuration, basically, to the system but the platform engineer security team building the security platform wants to use OPA [inaudible 00:44:13] all those RBACH policies and so that's something that's well supported today and we're continuing to [inaudible 00:44:21] and optimize.

Tim:                When it comes to management in this case, Netflix ended up rolling their own management layer. Netflix is good at replicating state and policy is an example of that so they rolled their own. I don't know if Minish is on the call or not, I saw his name on the folks in the working group but they rolled their own. The other thing that we've seen in this is using, for STO, using kubernetes custom resource definitions to store policy as well as data. That's something that may be coming out as part of STO in the near future. And then the other thing that we've seen in terms of management is we've seen several requests for sort of backends that will have OPA go out and pull policy out of post grass or S3 or something like that. And so the management goes beyond what OPA does for sure but it's a fairly simple kind of a sidecar management system.
                    All right. We'll keep on moving then. Another use case that was interesting here is in sort of public Cloud space and this one is really focused on Terraform in using Terraform to manage the public Cloud resources. So there were actually kind of two use cases that came out here. What happened was that ... there really two cases, right? One of which is, you've got an application developer who, or a platform engineer, who wants to make a change to public Cloud infrastructure so they go in to Terraform, they make some changes to the file and then they want to go ahead and apply those changes. 
                    And so what it was Medallia? So what Medallia wanted to do was take the plan that Terraform produces and compute a risk score for that plan and then decide whether or not that user's authorized to make that change all by himself without peer review, based on the risk score of the clan as well as based on how senior an employee they were. Right? So if you're a senior platform engineer then your risk score might be like a thousand and you can make any change up to that risk score but if you're a junior developer maybe you're only authorized to automatically execute risk scores under 100 or something. And here the risk score that they came up with was based on the networking ports that you open, the number of servers are you deleted and so on and so forth. We did convince them to add this risk score policy to our standard [inaudible 00:47:14].
                    The second kind of use case is sort of the backend of that which is once you've already used Terraform to push and manage your public Cloud resources, how do you know that people are only using Terraform to actually manage that infrastructure? And here the idea was, what Medallia did, was they took the, I think of AWS, they took the AWS, the state of AWS, all the resources in it and then they took the Terraform state file which represents what resources Terraform knows is under its management, you toss both of those into OPA and then you write policy that looks for differences, writes its way, show me a resource in the public Cloud that is not also in the Terraform state. So they're using that for audit.
                    Okay. Questions about those use cases? All right. Maybe to ground that, I do have an example here of the kind of input that would come in that would actually ask for in, this case, a risk score for this particular Terraform plan. And so there was no way, I don't know if any of you have seen Terraform plans but there's no way I could actually put on a slide so there's a whole bunch of ellipses here but you get the basic idea that is pretty much an arbitrary JSON document that tell you all the different properties that are being changed and then you've got to write some sort of policy logic that decides how risky that change is.
                    The decision here is a number, it's some risk score. Oh, and here I broke down the sort of two Terraform use cases in terms of these dimensions of comparison that we talked. Performance here was not a real issue, it's some person using it for the most part so it's not a big deal. Obviously here though the policies were quite sophisticated in terms of the kinds of inputs they required and in terms of the expressiveness you needed to actually compute a risk score. Decision was a number, we talked about that. We don't really have good visibility into how they're doing policy management in either of these cases but what seems sort of clear is that there aren't a thousand OPA's that they're using, there's you know one or two or 10 so management's is probably not all that important.
                    Okay, we did all that. Great. Any other questions about the Terraform use case? Okay. Moving on then. This is actually a recent category and we don't have as much data here but recently folks have been starting to use OPA to do data protection. Here we've got a couple of examples, open SDS, Mineo is new and Kafka's new, so all those. I don't have a ton to say here other than what I try to do is, again, talk through how each of these use cases of course correspond to those early dimensions that we talked about. Oh, and there's another one here, rate-limiting, that I didn't have on the graphic, this is also new. 
                    For the rate-limiting use case, the idea is that somebody wants to set up policies to control network rate limits and so we're still not quite sure exactly what they're doing there but what we do expect is that the performance is pretty high, again, this is sort of close to the microservice API case. And again, they're doing this thing that the Tauren talked about and I guess I had mentioned it to where they have a GUI or a YAML file for writing the core, the crux of the policy that people care about and then they're effectively treating that as data when they author policy in Rego.
                    Here are obviously the decisions' a number and the policy management, we know, is gonna be custom. Data protection is pretty similar here. I don't think there's anything new, again, performance is going to be key, decisions are typically allowed/denied as far as we can tell in this case.

Speaker 3:          I have a basic question, we're going through a lot of use cases that are different resources outlined there, does OPA have a specific schema for how resources are identified and basically defined and how attributes are set for those resources or is it very open-ended, it's like a JSON data file that gets uploaded and then you create policy on that?

Tim:                Yep, yep. It's the latter. We do not impose a schema on anyone and as I sort of mentioned earlier, I wouldn't know how to begin that. Right? And so what we did instead is what you mentioned second which is the input that you provide to OPA is any arbitrary JSON document and then the policy language, you know what that schema is going to be when you're writing policy and then you express the logic that makes whatever decision you need it to make there in the policy language so there's sort of basically a contract between the person who is setting up enforcement and doing that integration and the person writing policy so that once the integration for enforcement is done then you know the schema that you're writing policy over.

Speaker 3:          And how does the user it identity itself, coming to the policy decision making ... so you can write policies where in ... you have example policies where you have a user, right, for which that policy's applicable but in a real life use case, how does the user context flow into the policy, typical example, how did Netflix do it or in the communities example?

Tim:                Yeah. The standard way is to use something like a JOT, right? That's sort of an obvious way of doing it. Right? You have to user authenticate through a JOT and then you pass that JOT into OPA, OPA does have support, special support for JOT so that you can go and inspect internals and yeah, and then where we've had a couple of requests to actually be able to validate tokens within the policy. But in those cases we haven't sort of made ... again, same sort of questions at first which is that we don't require any sort of authentication scheme. It's pretty open-ended right now so you can pass in tokens as part of the input here. Right? Just imagine there's another field in this input document that's like called token and so in that sense we sort of assume that the user has solved authentication in some way, shape or form and that they have a trusted [inaudible 00:54:07] decisions from OPA and so they can provide that user and however they like. And then again, when you're writing policy you know how that user is being represent.

Tauren:             In case of Spring for example, they have a whole way of representing user details basically, right? And so we just take that object, we send it into OPA as JSON. Right? Then you get ... you know whether or not like that account is locked or whatever the attributes are that they define on the principle. Right? But they already have a schema for that so we don't you know force that to change in any way, we just let that get loaded in OPA as data and then you write policy over it. So there's no there's no coupling between OPA and the way objects choose to represent their information.

Tim:                Right. And the thing I'll add to that is that one of the ... you sort of want both of these things. Right? What you really like is to have a canonical way of writing policy over users, but what you'd also like is to make integration super simple so that you can churn out a whole bunch of these things. And so, the question is how do you achieve both? Right? Because if you couple OPA, as Tauren said, and then to the actual enforcement point well then you got to change OPA for every enforcement point, that doesn't work very well. So we've done the opposite which is to say well, we're not going to require any sort of schema for users or resources and OPA will accept any sort of JSON data as input but then in the policy language, the idea is it's expressive enough to be able to codify schemas or oncology's or whatever you want to call them, so that you can still author policy with this sort of canonical mounds, canonical user formats or whatever and then you just write a little bit of policy that connects whatever format that data comes in as, whether it's users or resources or whatever, into that canonical schema.
                    So what we do is we sort of try to get people the best of both worlds, make the integrations especially simple but also give people the option of writing, sort of, canonical policies. And so what's sort of missing there is sort of a standard library that says well, for Spring, for a Spring integration, then here's how you map the Spring user data into this canonical data format and for a kubernetes integration, here's how you map the kubernetes user information into that same canonical format. Now we support that, we support that kind of logic but it's just not in the standard library today.

Speaker 3:          Thank you.

Dan:                I have a question, do you only use the data and the policies as input to the decision or can OPA call out other services as well? For example, do JOT validation, if you write that by hand you would have to be able to call certificates to validate.

Tim:                Right. So the right picture in your head is that the input that comes in, which is shown here, there's the data that you can load from any data source, from any kind of system on the planet and then there's a policy of course and then all of that is local to the decision and then fairly recently we added the capability to, within policy, go and make an HTTP call to an external system. Here the idea is, the use case here, is really one where you can't, for whatever reason, load that data into OPA and so what you decide is that I'm gonna take an external ... I'm gonna take a dependency on some external service and the consequences of that from a performance and availability perspective, I'm willing to take that that availability and performance hit because there's just no other practical way to get the data I need in to make a policy decision.
                    So for example, if you had a gigantic databases, it was a terabyte large, well you're not gonna load that into OPA and if what you know is that on every policy I only need to make a single ... I only need to check of a single row exist in that database, well then you can use that external connector to go out during policy evaluation and check it that exists.

Dan:                And then another thing, have you ever looked into obligations allowing you to manipulate the data? That gives you some interesting policy.

Tim:                Yeah, yeah, for sure. Yeah. So yeah, as I mentioned earlier, we're working closely with Tristan and Sarah and they know all about obligations and advice.

Dan:                Yes, exactly.

Tim:                But yeah, exactly. The plan is for ... In OPA today you can express those kinds of concepts because the policy decisions can be these arbitrary JSON documents, you can include, well here's the advice and here the obligations. So from a caller's point of view you can return that kind of information. There's no [inaudible 00:58:55] support though inside of OPA to do that, that's not a thing that OPA knows about. But in some instances that's okay as long as you can express the obligations and advice that you care about because the burden is really on the client to actually do something with that advice and those obligations. But like I said, Sarah and Tristan are the experts there and we'll learn more as we afford them and V2.

Speaker 3:          Yeah. I think that we're really excited about that capability, right? And I think taking that layered approach makes a lot of sense, not putting ... we don't need to put all of the concerns and how it's going to be used into the policy evaluation itself. In fact, it's stronger if we don't. Right? Let's only put the concepts into it that we really, really need to because then it's powerful and can be used across many domains.

Tim:                Right, right.

Speaker 3:          At least that's my current thinking.

Tim:                Exactly. Yep. We're on the same page for sure. Okay, I do have some lessons learned, I'm not going to go through them because we're out of time but I'll leave you with this, stars on GitHub and participate on Slack, that'd be great. We'll try to post these slides.

Tauren:             Yeah. We'll put them on Slide Share and then put a link in the Docs. If you guys have questions feel free to hit us up. Yeah, there's lots of people talking about policy concerns Slack board so a lot of time a conversation drifts outside of just enforcement API or enforcement plane and it gets into the management plan and so we'd love to have people on there that have experience with that, that could contribute to the discussion. So yeah, but thanks a lot for giving us the opportunity to [inaudible 01:00:49].

Tim:                Any final questions or comments?

Speaker 3:          Thank you, it was a wonderful presentation, very informative. Thank you.

Tim:                All right, this was fun, we should do it again any time.

Dan:                Thanks Tim, thanks Tauren, really appreciate you helping us establish this use case.

Tauren:             Cool.

Tim:                All right, thanks everybody. See you next week.