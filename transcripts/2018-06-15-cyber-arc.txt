Dan:                (silence)
                    Hey, Jason. Who are we expecting to entertain?

Jason Mello:        So from ADP, Michael Hirawady is going to be joining. He's got the invite. I was chatting with him earlier. So he should be on.

Dan:                Okay. [inaudible 00:07:53].

Jason Mello:        Do we have agenda topics before we get into that, or is that what we wanted to kick off with? 

Dan:                It's actually going to be a primary discussion. We will do round of check-ins. Mark, do you have anything? Sorry, Mark has just [inaudible 00:08:11] us to the room. Sorry, Mark. We'll go around, and we'll check on both to see if they have any check-in items from working groups. But that will usually be at most, five minutes or so. 

Jason Mello:        Sounds good. Mike's on now. So once we get through those kind of updates, we can get kick right into things.

Dan:                Great. And they're... This has actually been not shared today. Share on. [inaudible 00:08:49]. 
                    (silence)
                    While folks are logging on, we're waiting for Sarah Allen to get us to quorum. We have a presentation today from the team at ADP, and we're going to go into a discussion around RBAC based security. 
                    So, soon, let me draw up the link to notes. [inaudible 00:10:27] notes.

Mark:               Hey, Dan, I'm here now. 

Dan:                Bring in the notes. So here's the minutes doc. If we can get a couple of volunteers, we have a use case today. We're going to have the discussion from the ADP team discussing action-based control in the enterprise use case. And a bit of ABAC versus RBAC. And so we really want to make sure we capture minutes today, so if we can get a couple folks. 

Mark:               I'll give it a shot, Dan. I'll fill you in on some work group stuff at the end if we have time. 

Dan:                Actually, if you want to do that in the beginning, or do you need to follow other work things? 

Mark:               No, it's pretty-

Dan:                So there's an agenda item.

Mark:               I can do that.

Dan:                Let me go ahead and get another individual signed up to Stribe. So Mark, the first victim. Who's next? Anyone else would like to join Mark in capturing minutes? The document is in our chat and we'd like to get a primary and alternate on that. 
                    Ray or Cherie, do have cycles today to take minutes? You want to take minutes? 

Ray:                I got it. 

Dan:                All right, thanks Ray.

Ray:                Cool, no worries. 

Cherie:             Yeah, Dan, I'm available for only half an hour, but I'll also jump in on the doc and try to take some notes. 

Dan:                Okay, cool. We've got Mark and Ray on it. So save it for the next... [inaudible 00:13:00] for next time. Appreciate it.

Cherie:             Sounds good.

Dan:                Okay, well, let's go ahead and get started and do any check-ins that folks might have from the various working groups. Mark, you said you had a check-in. So I'll go ahead and start with you. 

Mark:               Sure, this will be pretty short. So in the 2675 group, which is DevOps security, we did a briefing today on BSIM. I don't know if anybody on this call is using it, but it's pretty widely used with regulated industries. It's kind of your CSO's sort of guideposts to how to build out your organization, because it kind of identifies all the roles and responsibilities for your typical CSO operation.
                    Not so much in the weeds for development, and also, it's not very well-informed about DevOps, but there's enough in there and it has got enough visibility with high profile people that we're going to try to find some stuff in there to make some adaptations on the DevOps side.
                    So it's still preliminary, but I hope to both share what we get out of that from this group and also do the reverse, to see if we can't elevate the status of BSIM with the doers. Because the doers in the technology side are kind of skeptical about that framework. 
                    On the NIST side, the NIST risk management framework is out for public comment until Monday. And if anybody's interested in chiming in and trying to twist them in a different direction, like something less organizational, hint, hint, be my guest. That's open to the public. 
                    And I know from being on the NIST side, they read all the comments. They're required sort of by law or by edict inside of NIST to respond to them. The risk management framework is pretty important, because this version of it tries to do a crosswalk to 853 and cover the lifecycle issues with SDLC and deal with some of the newer technology. So if it falls short, it's kind of on us to not... It's on us to not help them get there in some response, in some guidance or other.
                    Let's see, another thing I wanted to bring up is, anybody on this group use Cucumber? One the challenges on a CN is-

Sarah Allen:        The testing framework? 

Mark:               Yeah.

Sarah Allen:        I have.  

Mark:               So Cucumber, and what's the... Garrick or something. There's another kind of pickle terminology.

Sarah Allen:        Gherkin?

Mark:               Yeah, that's the domain specific language that it uses. That's kind of a preference for an automated DevOps friendly, more security and risk aware framework, because it incorporates the domain aspect of things, in a systematic way that other ones do not. So I'm not sure what I'm going to do with it. I'm going to bring this to the standards groups that I'm in and say, hey, let's take a look at this, we need a way to address where to put our natural language annotations and artifacts for the automation process. So anyway, that's FYI. Nothing really new on that. I'm not a user of it. So I'm an advocate for DSLs, but who knows? They might do a terrible job of it. 
                    Let's see, I had one other topic. I forgot already. StackRox.

Dan:                So Mark, is the actionable the DSL and potential alignment with DSL with [inaudible 00:17:00]?

Mark:               Sorry, I didn't hear the beginning of your question, Dan. 

Dan:                So is the actionable item there, the DSL the being involved and the evaluation of that as a common language? 

Mark:               Right, right. So the challenge for everybody is how do you get from use cases, whatever you want to call them, use cases, scenarios, user stories, this stuff that's sitting in natural language, sometimes it's the results of a meeting, right? How do you get from that to something that's in the code, that's traceable, that explains why you answer the are you sure question with an explanation or you decide not to, or you decide not to even ask are you sure?
                    And as a whole, panoply of problems around connecting up the natural language things to that. So Cucumber and that parallel DSL tries to address that and make it natural language friendly, have a better continuity between code and the requirements process and the test harness and the rationale for the test harness. 
                    So maybe it's a little peripheral for CNCF and Kubernetes. But you got to be able to orchestrate these artifacts and figure out where to put them. And at least for revision control, you need automation to do that. So it seems appropriate to me at this juncture anyway. 
                    It may turn out to be yet another dead end and a whole pile of dead end solutions that have been trying to deal with this since the '60s. 

Sarah Allen:        So is NIST proposing that the requirements from, like the human scenario requirements would be implemented in Cucumber to have natural language representation of the language of what's the requirement? And then those will be able to be executed? 

Mark:               Right. You're extrapolating from where I'm at to where they might go. You're hearing a proposal from me, not a NIST idea.

Sarah Allen:        I see. So that's [crosstalk 00:19:03].

Mark:               The NIST work we've done so far is, you'll know what this looks like without looking at it. It's a spreadsheet with stuff in the first column being the to-dos and the stuff you never get around to going in the other direction, right? I'm exaggerating, but it's a spreadsheet driven kind of thing with one of the cells maybe being your natural language annotation from a meeting and how you do that and your requirements might differ if you have doors or one of these other legacy products to do it. 
                    But in the agile world, and when we're orchestrating this intersection of operations and code, it's not clear how to do that in a systematic way, that has traceability, that works for forensics and scalability. So whether Cucumber is the answer or not, it's novel enough to make us think differently about the paradigm. 
                    The last thing and this is short, my company's doing a proof of concept with StackRox. This is obviously a commercial provider that's doing security for containers. So it's kind of peripherally related. But DHS is a partial sponsor of this work, as well as my company. So I'm open to suggestions from CNCF community and this group as to what we might want to ask them, what tires to kick in the proof of concept with them.
                    It's going to be hosted in their cloud, with them doing most of the setup, but their initial concept for how to do the POC was to put Metasploit in there and try to kick the tires that way, and I was hoping for something more systematic than that. So just sharing that in case there's a connection. 
                    And that's all the time, I'm going to monopolize.

Dan:                Thank you, Mark, just an encouragement to drop some of those links into the notes when you have a second.

Mark:               Will do.

Dan:                So we can follow-up. Appreciate that. Anyone else have any working group check-ins to share? Or it's time to get moving, if not. Okay, well, I'm going to hand the sharing of the rest of our session today over to Sarah, not that she is here with us. And Sarah, Jason Mello is joined by Mike Hirawady, and I'll hand it over to Sarah first, and then let her kick things off. 

Sarah Allen:        Wonderful. Thanks, Dan. And I'm really excited to welcome Jason Mello, who's going to tell us about enterprise ABAC, I think. Jason? 

Jason Mello:        Hi. Kind of in the interest of, we've been talking about enterprise use cases, way back since the beginning of the working group here. Was thinking about where have we attribute based access controls? And then even more specifically, having use cases where there is kind of the approach or the ability to roll that up into RBAC. So kind of the combination there.
                    And so I thought that the work that we had done over at ADP and what Mike's team continues to do at ADP would be relevant in this situation. I'll just kind of give some high level framing and hand things off to Mike, who has kind of the salient details on things.
                    But what we were trying to accomplish was that we were building essentially a fairly kind of indeterminant runtime right into the HR domain. So what that means is that different organizations, excuse me, different development groups would have different needs around creating, essentially, eligibility on data access rights, on functional institution rights, what can they do, what can they not do? And applying that in different organizational hierarchies.
                    So there's going to be a number of different type of either attributes or criteria, which says, do I have access to this particular object or function? Do I have the ability to approve a given request? Kind of one of the typical scenarios, maybe something where there is leave approval, that is going through the system. Who can actually say approve that when maybe your direct line manager is say on vacation as well?
                    Those are kind of the different scenarios that we were uncovering. All the way down to the need for much more secured conditions where say access to social security numbers, or the ability to actually change someone's pay in the system. Depending on even the amount that you want to give them, in terms of a pay raise, your access rights may no longer be valid, given the inputs that you're driving through. So fairly kind of complex use cases with a lot of kind of variables.
                    So the fundamental approach was to say we can certainly kind of decorate the different actors in their actions and the system through attributes, but there would also need to be the addition of this notion of criteria based access as well. So I wouldn't term what we're going to go through as kind of a pure ABAC, but more so kind of a combination of ABAC and CBAC, criteria based.
                    And kind of with that, wanted to introduce my Michael Hirawady. Mike is, I guess, kind of principal solution architect over at ATP in the Lifion group, which essentially, is those folks... What's that, Mike? 

Mike Hirawady:      No, nothing. I just muted my microphone. Just make sure you guys can hear me. 

Jason Mello:        Oh, great. Yeah, so for that, being a solutions architect over there essentially means you're a technical product owner and you're architecting a lot of the kind of solutions that you're pushing forward. 
                    So with that, I'd like to introduce Mike, and thus we're going to take things a little bit further.

Mike Hirawady:      Thank you, Jason. Hi, everyone. So Jason already did the introduction. My name is Mike Hirawady. I'm the principal solution architect here, one of the principal solution architect here at Lifion by ADP.
                    So as Jason mentioned, one of my themes is actually working on building the access control layer for Lifion. So let me share my screen, let's see if you guys can see me, see this. Okay, let me know if you can see the PowerPoint. 

Sarah Allen:        I can see it.

Jason Mello:        We can see it.

Mike Hirawady:      Okay, great. So I created this deck, essentially to highlight what attribute based access control is, how is it different than role based and towards the end, I have several slides that show how we actually modify to work along the lines that Jason mentioned earlier, which is to take on more complex use cases that we see on the HR domain. And essentially introducing, what we call criterias into the access control layer. 
                    So this is high level, this is the agenda, we don't really have to stick to this. I just did this to structure my deck a bit. And if you guys have any questions along the way, feel free to ask and we can go over that.
                    So at a very high level, in a typical access control environment, at least the one that I've seen in most of the enterprises, they are still role based. At the basic authorization policy or access control rule, essentially, a subject needs to or can operate on an object. And the object in this case, it's also called resources, typically. It could be anything from data to individual say like servers or even like devices. So it's really fairly wide open.
                    So the combination of this subject, action and object is what we typically call a rule or a policy. So what is role-based access control? So it's a fairly manual process where you create a role or a security group and then typically, these policies that have been implemented by the developers are assigned and the users are manually assigned to it as well.
                    So a given example here, where it's system admins can log into production notes and execute scripts. Obviously, somebody needs to create the role system admin, manually. They need to assign the access control rule to login and to execute scripts also manually to the role itself. And even the users, sometimes they're part of a group, and the entire group is assigned to the role, or individual users are assigned to the role. 
                    Obviously, there are a lot of limitations here. If you imagine that somebody then comes along and say, I need like a more granular type of policy assignment, then there really isn't any other choice other than to create a new role or a new group. And obviously, that causes a proliferation of roles typically in the system. And as more and more of these edge cases come in, it's going to be more and more of these roles, it's going to be a headache to manage. And at some point, somebody will not really sure how somebody or a group gets assigned to a role.
                    So I've seen this happen before in the past. So... Sorry, somebody said something?
                    Okay, so how does attribute based access control help in this scenario? So this is actually a quote from the NIST project overview of attribute based access control. "In its most basic form, we basically relies upon the evaluation of attributes. The attributes itself can be off the subject, or off the object, or even on the environment."
                    So for example, like device type could be an attribute or IP addresses. So in the previous example, if somebody then comes along and say, well, this is still for the system admin group and this is still for managing access, so only them can log into the production nodes. However, I want to add this little quirk here that says in their office region.
                    With role-based access control system, typically, what they'll need to do is to create a new group, and then assign the proper person or groups to it. However, with the attribute based, what they can do is, we have this additional component. And I can go over this in more details later, where you basically assign additional rule that's based on the attribute. And it could be something as simple as if the subject, that office, that region attributes is equals to object .location, .region, right? Sorry, subject, office region equals to object, location, region. 
                    So once they set this up, what this means is, for each of the individual in the group, they could have different access to different nodes. Because during the decision-making time, we actually take this attribute roles into account. So it's not just looking at this at the higher level policy, which says can log into production nodes, we are also saying, well, you can log into production nodes, but we also need to check where the production node is located and where you are located and see if we can allow you access to that.
                    So does that makes sense so far?

Jason Mello:        We get everything, Mike.

Mike Hirawady:      All right, so going into the architecture a little bit, this is a typical architecture for an attribute based access control with the different components on it. So we basically have this policy enforcement point, where the decision is processed and access is given from the subject to the object. 
                    Typically, it is done at the product level. And what I mean by that is, if you're building a more generic access control, like the way we do here, depending on which product, somebody is allowed to do something means different things, right? It could mean, they could see somebody's time sheets, or it could mean they could modify somebody's compensation. 
                    But the data that we operate on is different, the action that they can operate on is different. So typically, the enforcement point is something that we expose maybe as an API or as a module for the products themselves to consume within their code.
                    And then you have the decision point. So this is kind of like the brain of the system. This is where every time a request comes in, they look at the assignment store, where the policy assignments are being stored. And once they have the assignment, they actually branch out to the third component here, the policy information point, which typically have one or more data sources, where they can retrieve the attributes for both the subject, for both the objects, and maybe even for the policy itself. 
                    And they basically pass that back to the decision point and the decision point is the ones that make the final allow or deny decision, potentially with additional information, and return that back to the enforcement point. So each of the product can do what it is that they need to do.
                    So these are essentially the standard components, standard names that is being used industry wide. There is no real guidelines on how they are implemented, whether it's a surface, it's a monolith, it could really be anything, as long as it meets the enterprise's needs. 
                    Now, that is the theory. However, I've been part of a team that built this in a couple of companies other than ADP. So what we find is, obviously, there are other stakeholders that are not really, have been taken into account in the standard implementation. Obviously, the developers will need to be able to implement these policies and apply them to whatever objects that they're working on and whatever subjects or actor that they're interested in.
                    The security admins themselves, they still need to configure roles, as we call them still, the policies as well that are assigned to their roles. But in addition to that, not necessarily assigning users manually, but they need to configure the attribute assignments, and the assignment rules for those attributes. They also need to do other things like running audit reports for their leadership.
                    And then obviously, the end user, they just want to log in and perform operations. They don't want to deal with, I can't really do this, because there's something wrong with the system. So the system just has to work. 
                    So in thinking about this, there are actually a couple more components that I feel like we need to introduce. One is what I call myself, policy configurator. Or it's essentially the toolkit for the developers to do the implementation. 
                    And then the second one is, I think the more important point here, is really what we call the policy administration point. So what does that mean? So the red areas here are the ones that we just added. So if you look at the flow essentially on how somebody needs to set this up, if I'm a developer, then I have to use this development toolkit during my implementation, so I can properly define my authorization policies. And that typically involves what I want the subject to be able to do, to the component or the object that I'm working on.
                    Once that's done, then I store it in this policy store. And then at configuration time, somebody like a security admin or maybe like an onboarding specialist or something, they can then go in and basically use some kind of a web UI or APIs or something that is provided by this administration point, to set up how the access control will actually work at runtime. So I found that these two components are essentially just basically a must-have for an access control to work. 
                    Now, we're getting to the interesting part. Once we have all these things set up, and especially at ADP, we realized that in order for us to be able to serve our users properly, we really need to make this as real-time as possible. So that's where this idea of dynamic assignment comes in. We're leveraging an event driven reactor pattern. 
                    So what we realized is that a lot of these attributes for both the subject and the object are actually coming from maybe just one or two more data sources. So what we do is we basically make the attribute repository link to the policy information point more on like a pub/sub mechanism. So it's going through a data pipe, could be like messaging queue, like a Kafka or Kinesis or something like that. And then the policy information point itself could be an event driven surface, that access a reactor.
                    So any changes that happens in any of the web app, or any other app that affects the attributes in the repository, we essentially get that change event in almost real-time. We can adjust the policy assignments properly. The other thing that needs to change here is that, because we are evaluating the attributes at runtime, sorry, in real-time, the store that we have is not really a policy assignment store anymore. It's turning into more of a runtime cache, because we're literally flattening out the policy assignments for each subject, and for each object based on their attributes. 
                    Does it make sense to anybody, any questions so far?

Sarah Allen:        I was wondering if you can go over exactly what is the use case that drives this event driven pattern, like the necessity for real-time. I think I'm getting it, but maybe you can just go over that again. 

Mike Hirawady:      So the one use case that is fairly general in the HR space is if somebody gets terminated. So typically, when somebody gets terminated for, let's say, for a gross violation of misconduct or something, we literally want to get them out the door as soon as possible. Because our access control is attributed based, we can basically say in all of our policies that we assigned to that employee, part of the attribute that we need to look at is if this employee record is an active employee, right? Or if the active date is still in the future, or sorry, it's... How do I say this? If there is no termination date in his or her record, I guess I should say.
                    So if we make that part of the attribute assignment in the access control policy itself, the minute somebody has their termination date updated with today's date, we can literally act on that change event immediately. And within seconds, that employee will not have access to anything anymore.
                    Does it makes sense?

Mark:               Yeah, if I could chime in here, part of the Kool-Aid for this, which is kind of exciting is that if it's event driven, you get the intersection of multiple events that normally your policy apparatus doesn't include.
                    So one of the examples of that is, I just had it in my head. It's when you have a rule that says nobody's allowed into this building without a badge, and the badge reader is located at eye height. But you might have some employees that are in protected classes, say they are in wheelchairs or whatever. So you can have rules that consult these protected classes, and have secondary policies that can be invoked based on this kind of information.
                    And typically, the policy creators don't think through all of these highly domain specific details. 

Mike Hirawady:      And another thing that I have seen this used in the past is to actually temporarily restrict access. So for example, because we're using attributes, there is one more sort of like concept that is standard, which is the environment attributes. And typically what that is, are things like IP ranges or device types. 
                    So let's say an enterprise is located all over the world, but they're still in data centers. So we have as a software provider for the enterprise, we know where the requests are coming from. And let's say they tell us one day that, hey, we have a breach in some of our data centers. Please restrict access from these IP ranges. We can literally block those IP ranges in our attribute repository, and our policy assignments with react immediately. So starting from that point on, any request that comes in, if we check for the IP address, and we see the IP address is coming in from this blocked data center, we will block access to it. 
                    Cool. So moving on, and again, this is getting more interesting. We looked at the type of data that we store, especially in ADP, in the HR domain. And we figured out that most of them are really hierarchical. So for example, the use cases they will deal with are things like a manager can only approve say time off for their employees, for their own reports. They can't approve anybody else that's outside of their teams. 
                    And we have other use cases like this, up and down the products. And that gets us to the think about how we can leverage sort of like a hierarchical data store. And Jason is actually a big part of this as well. So Jason, feel free to keep me honest, or chime in if you want to here. 

Jason Mello:        Will do.

Mike Hirawady:      So we introduced a graph database in our system. And wherever we can, we tried to centrally create a replicate source of truth from our real source of truth in a graph format, right? So with graph, you have the ability to represent entities or fields within entities as notes, and the relationship between those fields as the edges. And even though it's a graph, we can put limitations around it, so that we say, all right, this is kind of like a top down hierarchical type graph. So we can put some software validation around how the data gets entered and how the graph gets maintained.
                    I'm using like location IP addresses or degree of connections as examples here. But in our world, in the HR world, reporting structure is typically a very big hierarchical use case. Cost center is another one, right? So for example, if you're an enterprise company and you have five different cost centers that are at four or five different locations and it's cut across all the different departments, say like your compensation product or your budgeting product may need to look at those cost centers to decide who can act on which department's budget. Who can approve them, who can reject them, who can manage them, that type of stuff.
                    Now, what that means for the actual system itself is we actually put an extra layer in the middle here, before we evaluate the attributes for access control. What we do here is that the attribute repository still pushes change events out to the data pipe. But we have an additional subsystem, basically, in the middle, which is the graph reactor, which takes the same change events and wherever relevant, maintains the graph. 
                    So it updates the graph, it creates new nodes, creates new edges. And then the graph itself emits its own change events. The access control system now listens to the graph change events, wherever it's relevant. And depending on what changes, it will process and update the runtime assignment.
                    So this is basically how the system works at the moment. And this is sort of like the whole picture, I'm just going to close off this, this is basically what we've been discussing so far.
                    What I do want you to look at is this though. So once we started going down this path, and we were defining the products and the benefits of using the graph, two things that come up is, we can use it as a source of data for attributes, like what I just went through, as far as hierarchical scoping, what we call it, or data entitlement.
                    However, what makes it really powerful in our opinion, is that we can use the graph itself to represent the policy definition. For example, if we go back to the access control statement in the beginning, where you have your subject that can operate on an object, and when you think about roles and security groups, we can represent them as nodes in the graph. And then the graph edges essentially represent the relationship between them. So a subject belongs to a role and policies are assigned to the role and therefore, the subject is authorized to do those policies.
                    Thinking about graph and traversals within the graph, we can do so much more with the kind of traversal queries that we cannot do with a flat or relational data stores. So for example, if there is a role called a junior manager and there is a policy that says a manager can see their team members' compensation, and a manager can update their team members' compensation, we can actually create this more granular level of access control and allows for policy inheritance.
                    So what I mean by that is, a senior manager is at the level higher than a junior manager. If there is a role between, sorry, if there is a relationship between senior manager and junior manager in the graph, we can assign the see their team members' compensation policy to the junior manager role, therefore allowing them to have it. 
                    But then because the senior manager is a level above, we don't really need to reassign that policy again. Just because they're a senior manager, their access control essentially encapsulates everything that's below them. And in that case, we only need to update their team members' compensation policy at the senior manager role node.
                    And adjusting time access control changes, this is basically what we discussed earlier. Because everything is sort of like event driven, we are actually able to modify our runtime assignment. And since we're treating it more as a cache than of anything else, the decision-making process is literally changing, just in time as the attribute changes. 
                    Does it make sense to anyone, any questions on this? 

Jason Mello:        Yeah, Mike, just a question around non-hierarchical structures, and the ability to address kind of a similar thing, right? A scenario there would be maybe a number of employees are on the same project at a company, or they're part of the same group, but these are not structures that fall into the typical HR hierarchies. 

Mike Hirawady:      So basically, do you mean the criteria based type of structures?

Jason Mello:        Well, you had mentioned there the hierarchical. So the question was, can we apply these types of access pattern approaches in non-hierarchical structures? 

Mike Hirawady:      Yes. So in addition to the graph attributes that we use, we are still maintaining the ability to, essentially for somebody to create something almost like a SQL query, right? If the source of truth is flat or relational, then we can still query the attributes from the table that we're interested in. And via the same event driven mechanism, we can still adjust the policy real-time.
                    The criteria stuff though, it's something interesting that we could go into next, if there are no more questions. Does it makes sense, Jason?

Jason Mello:        Yeah, definitely. 

Mike Hirawady:      Okay, so-

Jason Mello:        Mike it was also a little bit of a leading question too.

Mike Hirawady:      I figured.
                    All right, so let's get into the criteria stuff. I don't actually have a slide for it. But basically, what that means is, what we find out when we're talking to a lot of our clients, ADP clients, the ability to define these attributes are really client specific. And even in some clients, large enough clients, it is almost department specific.
                    So what that means is, as a developer on the development side, there's only so much that we can do to predefine all these policies. We need to build a mechanism for the end user to define these attributes themselves, and apply them to policies at execution time, at runtime. 
                    So what we've come up with is a way for them to almost literally define their SQL query upfront. We, as I mentioned before, and as Jason alluded to, we actually still have two different types of attribute resolution. One is this graph based one and the second one is still the relational database, the flat data structure one.
                    So we are building what we call a criteria based system, where we will have a web API front end for say, like a security admin or even an HR admin to go in and define the data entitlement rule. So for example, if an HR manager says only a certain level of managers can actually approve promotions for their department or division, except for the people that are in another office location, that is not something that we can define on the development side of things. Just because it's so granular, and it's so specific. So that's why we need to do this. 
                    The criteria based right now is turning into more or less like an eligibility engine. So essentially, this is just another type of attribute that we need to resolve and store in our cache. So that when the user actually tries to perform an operation on our system, we check against this attribute as well. 
                    So the last slide I have here is really not about anything that we've done before and there's a reason for it. So there is an effort by this OASIS consortium to create an access control policy language, it's called XACML. It stands for extensible access control markup language. I think they started this effort in the early 2000s, they released their 3.0 version of the... 3.0 syntax of the language a few years back.
                    In one of my previous jobs, I actually tried to use this, it's very verbose and in most cases, in my mind, it's little bit an overkill, even for enterprise systems, but it is very verbose. I put some links in there as references, if you guys are interested. The Wiki page, believe it or not, actually has a great summary on it and it has all the external links in there. 
                    That's really all I have. So open for questions, if anybody has anything. Hopefully, this has been helpful. 

Sarah Allen:        Thank you, do folks on the call have questions?

Mark:               Oh, yes, we have questions. Thank you so much. This was very interesting and it's great to see somebody doing this. I talk about it a lot, not doing very much.
                    When you implemented this thing, was there a concern that given the sometimes fragility of highly scaled assets like Active Directory, that the access control thing that you built, let's just call it a thing, is too fragile to scale properly?

Mike Hirawady:      We haven't really seen that. So as far as what we're building now, we are still in, I would say, probably like the beta version of the product. But in my previous company, it was actually being used in a fairly large user base. I used to work at Comcast and this is literally what they used for their TV Everywhere initiative, in terms of determining if a user tries to go to say, like an HBO website and whether or not they actually purchase HBO. And we actually use XACML there. So the policy itself is pretty verbose. And we haven't really seen any issues with scalability. 
                    The one thing I would say though, on what we are doing now, we do take some precautions around the event driven system. The back end that essentially updates these policies real-time, because that's one of the areas where it's asynchronous, there's always like some precautions we need to make there.
                    So we do have other services, some sort of like a recon service essentially, that monitors discrepancies and tries to report on it and tries to fix it in real-time. But I haven't really seen any scalability issues, per se. It also, I think, as a part of the... the good thing about attribute based access control is that there is no really just one way to build this. And that's why they break it apart into those components. 
                    You can scale each of the components up or down, depending on your needs. So if you see a lot of attributes coming in, then maybe you want to scale your information point and your decision points. But you can keep your enforcement point in however mechanism you already have, or vice versa. 

Mark:               I take your point there. I guess I'm puzzled then why Microsoft has such a challenge with this. I mean, what's the best way to say this? I think their challenge is real, that the intersection of the number of people, the number of changes being made to policies, the number of groups that have to handle the crosswalk to all the resources that Active Directory and LDAP have to manage is a challenge by itself.
                    And if you try to put an overlay of attributes on top of that, because, really, that implementation, really, if you think about it is primitive in many senses, right? 

Mike Hirawady:      Yeah, exactly. I was just going to say, we have overlaid this type of system on an LDAP before, but honestly at that point, the LDAP is becoming no more than just sort of like groupings of users. We don't actually use sort of like their access control ability, we just basically use it as a user store at that point. 
                    They have other uses in terms of the security roles and domains and the more traditional sort of like AIM role setup that they have. But for like an enterprise, user-facing real-time apps that we're dealing with, it is a little too static. And I could see why that wouldn't scale. 

Mark:               Interesting. So let me ask one other thing before I relinquish the floor, and thanks for the forbearance, team. On the application development side, this is not a thing that developers understand. The idea of the attributes is tied to their domain model understanding of their application, which they're obviously not too well educated about in the first place. Even in the role world, they're not too well educated in.
                    The decision about what attributes need to be pushed out is one that they have to tackle for logging and auditing, as well as alerting. So I wonder how that got surfaced when you struggle with that. 

Mike Hirawady:      So I'll give you two examples, I guess. At Comcast, our attributes list isn't anywhere near as big as in ADP's, right? Because at the end of the day, it's like cable, cable channel, maybe device type, maybe browser type, maybe IP addresses. And those are, yes, those are domain specific, but the engineers there more or less know their domain.
                    What we're doing here at ADP is a completely different animal. We are actually building a platform. So even the engineers on the platform side, they don't know what the business logic is on the application that other people are building and other teams are building. So we actually build a generic...
                    So there are other generic platform functionalities that we are building that allows us to essentially hook into their source of truth. So if I'm an application developer, and I'm using the Lifion platform to build an application, I have a way already to figure out, to basically define the schema of my table, to basically define my SQL queries.
                    And as a part of that, we do on the authorization side, we do have access to the fields on the tables that people can use as attributes. So we're dealing with like a metadata on our side, essentially. And therefore, we left the domain knowledge of the attribute more at the business domain level. 
                    So if I'm working on like a payroll application, I know what all my payroll fields are and what they mean, and what kind of policies will need to put around it. So especially in the HR world and the payroll world, we deal a lot with PII and SPI, different personal information and personally identifiable information. 
                    So we do need to put some precautions around it. But we do realize that it's not possible for an engineer who's building this to understand all those attributes. So we just built a system using this method in a platform, to allow the application layer to have that business logic on their side. 
                    Does that make sense? Mark?

Mark:               I promised to shut up. But I have to jump in again with another question. Some of the use cases you gave us were, what we think of as in the security space, cross disciplinary, right? Like having to do with firewalls and infrastructure stuff, right? 

Mike Hirawady:      Absolutely. 

Mark:               Yeah. So that's in the security domain, if you want to think of it that way, in a simplistic sense. So that part is sort of hard coded, is that how you deal with it?

Mike Hirawady:      No, not necessarily. I mean, we haven't really used this, or at least I haven't, in sort of like an infrastructure type of policies. But the example that I gave you around like let's say, it's kind of like crossing both domains. So let's say a, what do you call it? A partner of Comcast, let's say HBO, right? HBO doesn't want people to access their website or their online streaming video app if they live in a certain region, or if they come in through like a certain IP ranges on their side.
                    We actually used that as a real use case and we have to look almost at the header level of the requests that are coming into us to retrieve all this IP information, what kind of like... and cross reference that with like a geolocation and make sure we allow or deny properly. But I have not really used it in terms of making sure that, what do you call it? Like a system admin role can only operate on say like a certain type of servers or certain type of databases, not on others. 
                    I think we're using a lot of like AWS product here and back at Comcast as well. I think the IM roles that they have can still be made more granular, but I don't think they're using this type of attribute based.

Sarah Allen:        Okay, I want to just interrupt, because we've just got a minute left. Thank you so much, Mike for the presentation. I think it sparked a lot of discussion. And Mark, thanks for all your questions. I want to point out that we had a prior presentation from OPA that talked about their Rego v2 policy language, which is I think an evolution of what XACML was trying to do. So if folks are interested, you can look back on that. 
                    And then I think next week on the 22nd, Dan has canceled the meeting. But I just want, if there's any last announcements or questions about what we're doing with the working group and next up things, I wanted to give a moment for that. 
                    Great. And then Mike, do you have a link to the slides in the GitHub issue or would you mind sharing those? 

Mike Hirawady:      I will share that after this.

Sarah Allen:        That would be fabulous. 

Mike Hirawady:      Sure. 

Sarah Allen:        Okay, so we'll officially wrap up the meeting, and thanks everybody for your participation today. 

Jason Mello:        Yeah. Thanks, everyone. Thank you, Mike.

Mike Hirawady:      No problem. Thanks for having me.

Jason Mello:        Really nice, thanks.